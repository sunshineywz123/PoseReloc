import argparse
from pathlib import Path
import random
import os
from loguru import logger
import numpy as np
import cv2
from tqdm import tqdm

OBJ_IDS = [
    '0601',
    # '0603',
    # '0604',
    # '0626',
    # '0627',
    # '0628',
    # '0629',
    # '0630',
    # '0631',
    # '0600',
    # '0602',
    # '0606',
    # '0607',
    # '0608',
    # '0610',
    # '0612',
    # '0613',
    # '0615',
    # '0618',
    # '0619',
    # '0620',
    # '0621',
    # '0622',
    # '0623',
    # '0624',
    # '0625',
    # '0633',
    # '0634',
    # '0635',
    # '0636',
    # '0637',
    # '0638',
    # '0639',
    # '0640',
    # '0641',
    # '0642',
    # '0643',
    # '0644',
    # '0645',
    # '0646',
    # '0647',
]
COPY_DIRS = ["color", 'Frames.m4v', "intrin_ba", "poses_ba", "reproj_box", 'intrinsics.txt']

def get_3d_box_pose(bbox_path):
    """ Read box rotation and translation from box file generated by ObjectScanner"""
    from scipy.spatial.transform import Rotation

    def parse_bbox(bbox_path):
        with open(bbox_path) as f:
            lines = f.readlines()
        data = [float(e) for e in lines[1].strip().split(',')]
        return data
    
    bbox_data = np.array(parse_bbox(bbox_path))
    tvec, qvec, scale = bbox_data[:3], bbox_data[-4:], bbox_data[3:6]
    
    tvec = tvec.reshape(3, 1)
    rvec = Rotation.from_quat(qvec).as_rotvec().reshape(3, 1)
    scale = scale.reshape(3, )
    return tvec, rvec, scale

def get_3d_box_scale(bbox_path):
    """ Read box rotation and translation from box file generated by ObjectScanner"""
    from scipy.spatial.transform import Rotation

    def parse_bbox(bbox_path):
        with open(bbox_path) as f:
            lines = f.readlines()
        data = [float(e) for e in lines[1].strip().split(',')]
        return data
    
    bbox_data = np.array(parse_bbox(bbox_path))
    tvec, qvec, scale = bbox_data[:3], bbox_data[-4:], bbox_data[3:6]
    
    scale = scale.reshape(3, )
    return scale

def get_3d_box(bbox_path):
    """ Get 3d box corners in canonical coordinate """
    try:
        tvec, rvec, scale = get_3d_box_pose(bbox_path)
        rotation = cv2.Rodrigues(rvec)[0]
    except:
        # Extract scale only!
        logger.warning(f"Can only extract scale data from bbox path:{bbox_path}")
        scale = get_3d_box_scale(bbox_path)
        rotation = np.eye(3)
        tvec = np.zeros((3,1))

    T = np.hstack((rotation, tvec))
    T = np.vstack((T, np.array([0, 0, 0, 1])))

    corner_in_cano = np.array([
        [-scale[0], -scale[0], -scale[0], -scale[0],  scale[0],  scale[0],  scale[0],  scale[0]],
        [-scale[1], -scale[1],  scale[1],  scale[1], -scale[1], -scale[1],  scale[1],  scale[1]],
        [-scale[2],  scale[2],  scale[2], -scale[2], -scale[2],  scale[2],  scale[2], -scale[2]],
        [1, 1, 1, 1, 1, 1, 1, 1]
    ]).T
    corner_in_cano = corner_in_cano[:, :3] * 0.5
    return corner_in_cano, T


def get_trans_box(trans_box_path):
    with open(trans_box_path, 'r') as f:
        lines = f.readlines() 
    
    data = [float(e) for e in lines[1].split(' ')]
    scale = np.array(data[0])
    rot_vec = np.array(data[1:4])
    trans_vec = np.array(data[4:])

    return scale, rot_vec, trans_vec

def trans_corner(orig_corner, trans_box_path):
    """
    @orig_corner: [n, 3]
    @trans_box_path: scale, rvec, tvec 

    return: 
        trans_corner [n, 3]
    """
    scale, rot_vec, trans_vec = get_trans_box(trans_box_path)

    corner_in_cano_homo = np.concatenate([orig_corner, np.ones((orig_corner.shape[0], 1))], axis=-1)
    corner_in_cano_homo = corner_in_cano_homo.T
    transformation = np.eye(4)
    transformation[:3, :3] = cv2.Rodrigues(rot_vec)[0]
    transformation[:3, 3:] = trans_vec.reshape(3, 1)

    trans_corner_in_cano_homo = transformation @ corner_in_cano_homo
    trans_corner_in_cano_homo[:3] /= trans_corner_in_cano_homo[3:]

    return trans_corner_in_cano_homo[:3].T

def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    # Input:
    parser.add_argument(
        "--data_base_path", type=str, default="/cephfs-mvs/3dv-research/hexingyi/arscan_aligned/arscan_data",
    )

    parser.add_argument(
        "--output_path", type=str, default="/cephfs-mvs/3dv-research/hexingyi/nips_data_release",
    )


    args = parser.parse_args()
    return args

if __name__ == '__main__':
    args = parse_args()

    data_base_path = Path(args.data_base_path)
    assert data_base_path.exists()
    output_path = Path(args.output_path) / 'OnePose_LowTexture'
    output_scanmodel_path = Path(args.output_path) / 'OnePose_LowTexture_scanmodel'
    
    # Parse id to full dir name
    object_dirs = list(data_base_path.glob('*'))
    id2full_dirname = {obj_dir.name[:4]: obj_dir for obj_dir in object_dirs}

    aim_obj_dirs = [id2full_dirname[obj_id] for obj_id in OBJ_IDS]
    random.shuffle(aim_obj_dirs)
    object_dirs = object_dirs

    for idx, obj_dir in tqdm(enumerate(aim_obj_dirs), total=len(aim_obj_dirs)):
        # Parse each object
        obj_dir_name = obj_dir.name
        id, name, category = obj_dir_name.split('-')

        id_new = id.replace('06', '07')
        output_obj_dir = output_path / '-'.join([id_new, name, category])
        if output_obj_dir.exists():
            output_obj_dir.rmdir()
        output_obj_dir.mkdir(parents=True)

        output_scan_obj_dir = output_scanmodel_path / '-'.join([id_new, name, category])
        if output_scan_obj_dir.exists():
            os.system(f"rm -rf {str(output_scan_obj_dir)}")
        for ply_path in obj_dir.glob('*.ply'):
            output_scan_obj_dir.mkdir(parents=True, exist_ok=True)
            os.system(f"cp -r {str(ply_path)} {str(output_scan_obj_dir)}")
        for texture_path in obj_dir.glob('*.jpg'):
            output_scan_obj_dir.mkdir(parents=True, exist_ok=True)
            os.system(f"cp -r {str(texture_path)} {str(output_scan_obj_dir)}")

        sub_seqs = obj_dir.glob('*-*')
        for sub_seq in sub_seqs:
            seq_id = sub_seq.name.split('-')[1]
            if int(seq_id) > 2:
                continue
            output_seq_dir = output_obj_dir / '-'.join([name, seq_id])
            output_seq_dir.mkdir(parents=True)

            for preserve_file_name in COPY_DIRS:
                src_path = sub_seq / preserve_file_name
                assert src_path.exists()
                os.system(f"cp -r {str(src_path)} {str(output_seq_dir)}")
            
            if seq_id == '1':
                # Parse aligned bbox:
                bbox_path = sub_seq / "Box.txt"
                bbox_trans_path = sub_seq / "Box_trans.txt"
                output_box_path = output_obj_dir / 'box3d_corners.txt'

                corner_in_cano, _ = get_3d_box(str(bbox_path))
                corner_in_cano = trans_corner(corner_in_cano, str(bbox_trans_path))
                np.savetxt(str(output_box_path), corner_in_cano)
        
